## 트리

- 트리는 데이터를 저장하고 탐색하기에 유용한 구조를 가지고 있다.
- 계층 구조를 표현하는 용도로 많이 사용
- eg. 파일 시스템, 디렉토리 구조 등

## 노드

- 트리를 구성하는 요소
- 노드 중 **가장 상위 노드**를 **루트 노드**라고 함

## 에지

- 노드와 노드 사이에는 **이어주는 선**이 존재함
- 이를 **에지**라고 부름
- 단방향 간선으로 연결되어 있고, 루트 노드에서 각 노드까지 경로는 유일

## 부모-자식, 형제 관계 노드

- 간선으로 연결된 노드들은 서로 부모-자식 관계가 있다고 표현
- 직접 연결된 노드 중 **상대적으로 위**에 있는 노드가 **부모 노드**, **아래**에 있는 노드가 **자식 노드**
- **같은 부모 노드**를 갖는 노드를 **형제 노드**라고 함

## 리프 노드

- 자식이 없는 노드
- 말단 노드라고도 불림

## 차수

- 아래로 향하는 간선의 개수

## 이진트리

- 이진트리는 배열이나 포인터로 구현할 수 있다.
- 이진 트리는 노드 하나가 최대 2개의 자식 노드를 갖는다.

## 배열로 표현하기

배열은 선형 자료구조이고, 트리는 계층 자료구조다. 따라서 배열로 트리를 표현하려면 3가지 규칙이 필요하다. 이 규칙은 루트 노드를 배열 인덱스 1번이라고 생각하여 작성한 규칙이다.

- 루트 노드는 배열 인덱스 1번에 저장
- 왼쪽 자식 노드의 배열 인덱스는 **부모 노드의 배열 인덱스 \* 2**
- 오른쪽 자식 노드의 배열 인덱스는 **부모 노드의 배열 인덱스 \* 2 + 1**

인덱스 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
값 ---- x 1 4 8 3 5 x 7 2 x xx xx xx xx 6

트리를 표현한 배열을 보면 빈 값이 많이 보인다. 노드들의 부모-자식 관계를 곱셈 연산하여 배열의 인덱스로 사용하기 때문에 실제 노드 개수보다 많은 공간을 사용할 수밖에 없다. 즉, 배열로 트리를 표현하면 자식이 없거나 쓰지 않는 인덱스들은 모두 빈 값이므로 메모리가 낭비된다는 단점이 있다.

그러나 이진트리를 배열로 표현하는 방식은 굉장히 구현 난이도가 쉬워, 메모리만 넉넉하다면 구현시간을 단축하는 용도로 좋다. 대부분의 코딩테스트에서는 배열로 이진 트리를 구현해도 괜찮은 경우가 많다.

## 이진 트리 순회하기

- 전위 순회
  - 현재 노드를 부모 노드로 생각했을 때 부모 노드 > 왼쪽 자식 노드 > 오른쪽 자식 노드 순서로 방문
  - 트리를 복사할 때 많이 사용
- 중위 순회
  - 현재 노드를 부모 노드로 생각했을 때 왼쪽 자식 노드 > 부모 노드 > 오른쪽 자식 노드 순서로 방문
  - 정렬된 순서대로 값을 가져올 때 사용
- 후위 순회
  - 현재 노드를 부모 노드로 생각했을 때 왼쪽 자식 노드 > 오른쪽 자식 노드 > 부모 노드 순서로 방문
  - 트리 삭제에 자주 활용
  - 노드를 삭제 할 떄는 부모를 먼저 삭제 하면 안 됨, 자식 노드부터 삭제해야 트리를 유지하며 재귀로 루트 노드까지 삭제할 수 있기 때문 그래서 후위 순회를 사용함

## 포인터로 표현하기

포인터로 트리를 표현하려면 노드부터 정의해야합니다.
노드는 노드의 값, 왼쪽 자식 노드, 오른쪽 자식 노드를 가집니다.

## 이진 탐색 트리 구축하기

이진 탐색 트리의 대상 데이터가 3 > 4 > 2 > 8 > 9 > 7 > 1 순서로 들어온다고 생각하고 이진 탐색 트리부터 구축합시다. 이진 탐색 트리는 데이터 크기를 따져 현재 노드보다 값이 작으면 왼쪽 자식 위치에, 크거나 같으면 오른쪽 자식 위치에 배치하는 독특한 정렬 방식을 갖고 있습니다.

1. 최초의 데이터는 루트 노드가 됩니다. 3을 이진 탐색 트리에 루트 노드로 추가합니다.
2. 현재 삽입하려는 데이터는 4입니다. 3보다 크므로 오른쪽 자식 위치에 배치합니다.
3. 현재 삽입하려는 데이터는 2입니다. 3보다 작으므로 왼쪽 자식 위치에 삽입합니다.
4. 현재 삽입하려는 데이터는 8입니다. 8은 3보터 크므로 오른쪽 자식 위치를 봅니다. 이미 자식이 있는 경우 값을 비교합니다. 8은 4보다 크므로 오른쪽 자식 위치를 봅니다. 위치가 비어 있으므로 8을 배치합니다.
5. 9는 3보다 크므로 오른쪽을 봅니다. 4보다도 크므로 다시 오른쪽을 봅니다. 8보다도 큽니다. 오른쪽에 배치합니다.
6. 7은 3보다 크고, 4보다 크고, 8보다는 작으므로 8의 왼쪽 자식에 배치합니다.
7. 1은 3보다 작고, 2보다 작으니 2의 왼쪽에 배치합니다.

## 이진 탐색 트리 탐색하기

이진 탐색 트리를 탐색하는 방법은 다음과 같습니다.

1. 찾으려는 값이 현재 노드의 값과 같으면 탐색을 종료하고, 크면 오른쪽 노드를 탐색합니다.
2. 본인이 찾으려는 값이 현재 노드의 값보다 작으면 왼쪽 노드를 탐색합니다.
3. 값을 찾으면 종료합니다. 노드가 없을 때까지 탐색했는데 값이 없으면 현재 트리에 값이 없는 겂니다.

만약 위에서 만든 트리에서 5를 찾는다고 가정하면, 3보다 크니 오른쪽, 6보다 작으니 왼쪽을 봅니다. 왼쪽에는 아무것도 없습니다. 이진 탐색 트리를 구축한 방식대로 찾았을 때 5가 없으므로 이 트리에는 5가 없다고 판단해도 됩니다.

## 배열 탐색과 비교

배열 탐색은 순차적으로 탐색하기 때문에 7번의 비교연산을 했다면, 이진 탐색 트리는 단 2번반 비교 연산을 진행하여 알아낼 수 있습니다.

## 이진 탐색 트리의 시간 복잡도

이진 탐색 트리의 시간 복잡도는 트리 균형에 의존합니다. 만약 이진 탐색 트리의 균형이 맞지 않으면 최악의 경우 O(N)과 같다라고 이야기 합니다.

## 몸풀기 문제

## 트리 순회

이진 트리를 표현한 배열 nodes를 인자로 받습니다. 예를 들어서 nodes가 [1, 2, 3, 4, 5, 6, 7]이면 다음과 같은 트리를 표현한 것입니다. 해당 이진 트리에 대하여 전위 순회, 중위 순회, 후위 순회 결과를 반환하는 solution( ) 함수를 구현하세요.

제약 조건
• 입력 노드값의 개수는 1개 이상 1,000개 이하이다.
• 노드값은 정수형이며, 중복되지 않는다.

입출력의 예
nodes return
[1, 2, 3, 4, 5, 6, 7] [“1 2 4 5 3 6 7”, “4 2 5 1 6 3 7”, “4 5 2 6 7 3 1”]
